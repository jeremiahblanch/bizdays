<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
  </head>
  <body>
    
    <script >
const oneDayMs = 24 * 60 * 60 * 1000;
const makeMidnight = (d) => d.setHours(0,0,0,0);

const reduceByDay = (startDate, endDate, reducer, initValue) => {
  const startDateMs = Number(startDate);
  const endDateMs = Number(endDate);

  // debugger;
  let arr = [];
  // if dates are less than one day apart
  // or end is before start
  if ((startDateMs + oneDayMs) < endDateMs) {
    arr = Array(
      // difference in milliseconds divided by milliseconds in a day gets difference in days
      // use ceil to handle fractions of days: always round up, then deduct 1 to ignore start date
      Math.ceil((endDateMs - startDateMs) / oneDayMs) - 1
      )
      .fill();
  }

  return arr.reduce((acc, curr, index) => {
    return reducer(acc, (
      new Date(startDateMs + (index + 1) * oneDayMs)
    ));
  }, initValue);
}


const allDaysBetween = (startDate, endDate) => {
  const startDateMs = Number(startDate);
  const endDateMs = Number(endDate);

  // if dates are less than one day apart
  // or end is before start
  if ((startDateMs + oneDayMs) >= endDateMs) {

    console.log('dates not far enough apart');
    return [];
  }

  return Array(
    // difference in milliseconds divided by milliseconds in a day gets difference in days
    // use ceil to handle fractions of days: always round up, then deduct 1 to ignore start date
    Math.ceil((endDateMs - startDateMs) / oneDayMs) - 1
    )
    .fill()
    // because we don't want to include start and end dates, start at index + 1
    .map((_, index) => new Date(startDateMs + (index + 1) * oneDayMs));
};

const incrementDay = (startDate, endDate, reducer, initValue) => {
  const startDateMs = Number(startDate);
  const endDateMs = Number(endDate);

  let curr = startDateMs + oneDayMs;
  let acc = initValue;

  while (curr < endDateMs) {
    acc = reducer(acc, new Date(curr));
    curr += oneDayMs;
  }

  return acc;
}

const incrementTimestamp = (startMs, endMs, deltaMs, reducer, initValue) => {
  let curr = startMs + deltaMs;
  let acc = initValue;

  while (curr < endMs) {
    acc = reducer(acc, curr);
    curr += deltaMs;
  }

  return acc;
}


WeekdaysBetweenTwoDates = (firstDate, secondDate) => {
    // date.getDay() returns 0 for Sunday, 1 for Monday, 5 for Friday, 6 for Saturday,
    return allDaysBetween(firstDate, secondDate).reduce((count, dayDate) => {
      const dayNum = dayDate.getDay();

      return count + ((dayNum !== 0 && dayNum !== 6) ? 1 : 0);
    }, 0);
  }

WeekdaysBetweenTwoDatesByReducer = (firstDate, secondDate) => {
  // date.getDay() returns 0 for Sunday, 1 for Monday, 5 for Friday, 6 for Saturday,
  return reduceByDay(firstDate, secondDate, (count, dayDate) => {
    // debugger;
    const dayNum = dayDate.getDay();

    return count + ((dayNum !== 0 && dayNum !== 6) ? 1 : 0);
  }, 0);
}

WeekdaysBetweenTwoDatesByIncrement = (firstDate, secondDate) => {
  // date.getDay() returns 0 for Sunday, 1 for Monday, 5 for Friday, 6 for Saturday,
  return incrementDay(firstDate, secondDate, (count, dayDate) => {
    // debugger;
    const dayNum = dayDate.getDay();

    return count + ((dayNum !== 0 && dayNum !== 6) ? 1 : 0);
  }, 0);
}

WeekdaysBetweenTwoDatesByIncrementTimestamp = (firstDate, secondDate) => {
  // date.getDay() returns 0 for Sunday, 1 for Monday, 5 for Friday, 6 for Saturday,
  return incrementTimestamp(
    makeMidnight(firstDate),
    makeMidnight(secondDate),
    oneDayMs,
    (count, currMs) => {
    // debugger;
    const dayNum = (new Date(currMs)).getDay();

    return count + ((dayNum !== 0 && dayNum !== 6) ? 1 : 0);
  }, 0);
}

BusinessDaysBetweenTwoDatesByIncrement = (firstDate, secondDate, publicHolidays = []) => {

  const firstDateMidnight = makeMidnight(firstDate);
  const secondDateMidnight = makeMidnight(secondDate);

  const publicHolidayMidnights = publicHolidays.map(makeMidnight);

  return incrementDay(firstDateMidnight, secondDateMidnight, (count, dayDate) => {
  
    if (publicHolidayMidnights.includes(Number(dayDate))) {
      return count;
    }

    const dayNum = dayDate.getDay();

    if (dayNum === 0 || dayNum === 6) {
      return count;
    }


    return count + ((dayNum !== 0 && dayNum !== 6) ? 1 : 0);
  }, 0);
}


BusinessDaysBetweenTwoDatesByIncrementTimeStamp = (firstDate, secondDate, publicHolidays = []) => {

  const firstDateMidnight = makeMidnight(firstDate);
  const secondDateMidnight = makeMidnight(secondDate);

  const publicHolidayMidnights = publicHolidays.map(makeMidnight);
  return incrementTimestamp(
      makeMidnight(firstDate),
      makeMidnight(secondDate),
      oneDayMs,
      (count, currMs) => {
    
        if (publicHolidayMidnights.includes(currMs)) {
          return count;
        }
        const dayNum = (new Date(currMs)).getDay();

        if (dayNum === 0 || dayNum === 6) {
          return count;
        }
        return count +1;
    }, 0);
}


const casesOne = [
  {start: '7 October 2013', end: '9 October 2013', expected: 1},
  {start: '5 October 2013', end: '14 October 2013', expected: 5},
  {start: '7 October 2013', end: '1 January 2014',  expected:61},
  {start: '7 October 2013', end: '5 October 2013', expected: 0},
  {start: '7 October 2013', end: '5 October 2033', expected: 5216},
  {start: '7 October 1983', end: '5 October 2073', expected: 5216},
];

const publicHolidays = [
  '25 December 2013', '26 December 2013', '1 January 2014',
];

const casesTwo = [
  {start: '7 October 2013', end: '9 October 2013', publicHolidays, expected: 1},
  {start: '24 December 2013', end: '27 December 2013', publicHolidays, expected: 0},
  {start: '7 October 2013', end: '1 January 2014', publicHolidays, expected: 59},

];


const run = (fn, cases) => cases.map(({start, end, publicHolidays, expected}) => {
  const result = fn(new Date(start), new Date(end), (publicHolidays ?? []).map(p => new Date(p)));
  
  return { result, expected, pass: result === expected};
});

let startTime;

startTime = performance.now();
console.log(run(WeekdaysBetweenTwoDates, casesOne ));
console.log(startTime, 'duration for array v', performance.now() - startTime)

startTime = performance.now();
console.log(run(WeekdaysBetweenTwoDatesByReducer, casesOne ));
console.log(startTime, 'duration for reducer', performance.now() - startTime)

startTime = performance.now();
console.log(run(WeekdaysBetweenTwoDatesByIncrement, casesOne ));
console.log(startTime, 'duration for WeekdaysBetweenTwoDatesByIncrement', performance.now() - startTime)


startTime = performance.now();
console.log(run(BusinessDaysBetweenTwoDatesByIncrement, casesTwo ));
console.log(startTime, 'duration for BusinessDaysBetweenTwoDatesByIncrement', performance.now() - startTime)

startTime = performance.now();
console.log(run(WeekdaysBetweenTwoDatesByIncrementTimestamp, casesOne ));
console.log(startTime, 'duration for WeekdaysBetweenTwoDatesByIncrementTimestamp', performance.now() - startTime)


startTime = performance.now();
console.log(run(BusinessDaysBetweenTwoDatesByIncrementTimeStamp, casesTwo ));
console.log(startTime, 'duration for BusinessDaysBetweenTwoDatesByIncrementTimeStamp', performance.now() - startTime)


</script>

  </body>
</html>